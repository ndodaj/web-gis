import { Component, ElementRef, OnInit, ViewChild } from '@angular/core';
import {
  FormControl,
  FormGroup,
  UntypedFormBuilder,
  UntypedFormGroup,
} from '@angular/forms';
import { Chart } from 'chart.js/auto';
import { AutoUnsubscribe } from '@core/utils';
import { SharedModule } from '@shared/shared.module';
import { IndicatorDtoService } from '@core/api/services/indicator-dto.service';
import { take, tap } from 'rxjs';
import { MatDialog } from '@angular/material/dialog';
import { SelectIndicatorComponent } from './components/create-edit-user/select-indicator.component';
import { BaseService } from '@core/api/base-service';
import { jsPDF } from 'jspdf';
import { AppConfigService } from '@core/services/app-config.service';
import { MatSnackBar } from '@angular/material/snack-bar';
import { DatePipe } from '@angular/common';
@AutoUnsubscribe
@Component({
  selector: 'app-raports',
  templateUrl: './raports.component.html',
  standalone: true,
  imports: [SharedModule],
  providers: [DatePipe],
})
export class RaportsComponent extends BaseService implements OnInit {
  indicators: any;
  selectedLayer: any;
  form!: UntypedFormGroup;
  form2!: UntypedFormGroup;
  selectedLayerInChart: any;
  features!: any;
  yearView = 'year'; // This sets the year view for the datepicker
  selectedYear = new Date(); // Initialize selectedYear with the current year
  link: any;
  featuresToGenerateRaport: any = [];
  @ViewChild('myChart') myChart!: ElementRef;
  myChartInstance: Chart | undefined; // Define myChartInstance property
  selectedChartType = 'bar';
  constructor(
    private indicatorDtoService: IndicatorDtoService,
    private fb: UntypedFormBuilder,
    private dialog: MatDialog,
    config: AppConfigService,
    private datePipe: DatePipe,
    private snackBarService: MatSnackBar
  ) {
    super(config);
  }
  ngOnInit() {
    this.indicatorDtoService
      .getIndicators({
        page_size: 5000,
      })
      .pipe(
        take(1),
        tap((indicators: any) => {
          this.indicators = indicators.result;
        })
      )
      .subscribe();

    this.form = this.fb.group({
      indicator: [undefined],
    });
    this.form2 = new FormGroup({
      start: new FormControl<Date | null>(null),
      end: new FormControl<Date | null>(null),
    });

    this.form.get('indicator')?.valueChanges.subscribe(() => {
      if (this.myChartInstance) {
        this.myChartInstance.destroy(); // Destroy existing chart
      }
    });
  }
  formattedStartDateValue() {
    const dateValue = this.form2.get('start')?.value;
    if (!dateValue) return null;

    // Convert to UTC ISO string and remove milliseconds
    const isoString = new Date(dateValue).toISOString().slice(0, -5) + 'Z';
    return isoString;
  }
  formattedEndDateValue() {
    const dateValue = this.form2.get('end')?.value;
    if (!dateValue) return null;

    // Convert to UTC ISO string and remove milliseconds
    const isoString = new Date(dateValue).toISOString().slice(0, -5) + 'Z';
    return isoString;
  }
  getAllProperties() {
    const startDate = new Date(this.formattedStartDateValue()!);
    const endDate = new Date(this.formattedEndDateValue()!);

    // Initialize featuresToGenerateRaport as an empty array
    this.featuresToGenerateRaport = [];

    this.indicators.forEach((indicator: any) => {
      this.selectedLayer = this.convertToSnakeCase(indicator?.name);
      this.link = `${this.geoserverUrl}/geoserver/test/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=test:${this.selectedLayer}&maxFeatures=500&outputFormat=application/json`;

      fetch(this.link)
        .then((response) => {
          if (!response.ok) {
            throw new Error('Network response was not ok');
          }
          return response.json();
        })
        .then((data) => {
          const features = data?.features;

          if (features.length > 0) {
            // Filter features based on date criteria
            const filteredFeatures = features.filter((feature: any) => {
              return (
                feature.properties.hasOwnProperty('date_time') &&
                new Date(feature.properties['date_time']) >= startDate &&
                new Date(feature.properties['date_time']) <= endDate
              );
            });

            // Push filtered features to featuresToGenerateRaport
            this.featuresToGenerateRaport.push(...filteredFeatures);

            // Do something with filtered features
          }
        })
        .catch((error) => {
          console.error('There was a problem with the fetch operation:', error);
        });
    });
  }
  generatePDFReport() {
    if (this.featuresToGenerateRaport?.length > 0) {
      const doc = new jsPDF();
      let y = 20;

      doc.setFontSize(18);
      doc.text('Report Generated by Date Time', 10, y);
      y += 10;

      this.featuresToGenerateRaport.forEach((feature: any, index: any) => {
        const stringBeforeDot = feature?.id.split('.')[0];
        const convertedString = stringBeforeDot
          .replace(/_/g, ' ')
          .replace(/\b\w/g, (char: any) => char.toUpperCase());

        const dateTime = this.formatDate(
          new Date(feature?.properties['date_time'])
        );
        const content = `${convertedString}: DateTime - ${dateTime}`;

        const properties = Object.entries(feature.properties)
          .filter(
            ([key]) =>
              !['gid', 'accepted', 'picture', 'id', 'date_time'].includes(key)
          )
          .map(([key, value]) => `${key}: ${value}`)
          .join('\n');

        const contentHeight = doc.getTextDimensions(content).h;
        const propertiesHeight = doc.getTextDimensions(properties).h;

        // Check if there's enough space for content and properties
        if (
          y + contentHeight + propertiesHeight + 20 >
          doc.internal.pageSize.height
        ) {
          doc.addPage();
          y = 20;
        }

        doc.setFontSize(12);
        doc.text(content, 10, y);
        y += contentHeight + 5;

        doc.setFontSize(10);
        doc.text(properties, 15, y);
        y += propertiesHeight + 10;

        // Add space between features
        if (index !== this.featuresToGenerateRaport.length - 1) {
          y += 10; // Add extra space between features
        }
      });

      doc.save('general_report.pdf');
    } else {
      this.snackBarService.open(
        'Please Get Properties First to Generate Report'
      );
    }
  }

  formatDate(date: Date): string {
    // Use DatePipe to format the date to your desired format
    // Parse the original date string using moment.js

    // Convert the adjusted date to the desired format
    const convertedDate = this.datePipe.transform(date, 'dd/MM/yyyy') as string;

    return convertedDate;
  }
  getProperties() {
    if (this.myChartInstance) {
      this.myChartInstance.destroy(); // Destroy existing chart
    }
    const { indicator } = this.form.getRawValue();

    if (indicator) {
      this.selectedLayer = this.convertToSnakeCase(indicator);
      //console.log(this.selectedLayer);
      this.link = `${this.geoserverUrl}/geoserver/test/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=test:${this.selectedLayer}&maxFeatures=500&outputFormat=application/json`;
      //console.log(this.link);
      fetch(this.link)
        .then((response) => {
          if (!response.ok) {
            throw new Error('Network response was not ok');
          }
          return response.json();
        })
        .then((data) => {
          const features = data?.features;

          if (features.length > 0) {
            this.dialog
              .open(SelectIndicatorComponent, {
                data: features,
              })
              .afterClosed()
              .pipe(
                take(1),
                tap((result) => {
                  if (result) {
                    this.createChart(
                      result?.chartType,
                      features,
                      result?.xAxisLabel,
                      result?.yAxisLabel
                    );
                  }
                })
              )
              .subscribe();
          } else {
            this.snackBarService.open('Indicator Does Not Have Data');
          }
        })
        .catch((error) => {
          console.error('There was a problem with the fetch operation:', error);
        });
    }
  }
  convertToSnakeCase(inputString: any) {
    // Convert to lowercase and remove special characters except spaces and colons

    return inputString
      .toLowerCase()
      .replace(/[: \/]/g, '_')
      .replace(/\s+/g, '')
      .replace(/_+$/, '');
  }

  createChart(
    selectedChartType: any,
    features: any,
    xAxisProperty: any,
    yAxisProperty: any
  ) {
    const labels = features.map(
      (feature: any) => feature?.properties[xAxisProperty]
    );

    const dataValues = features?.map(
      (feature: any) => feature?.properties[yAxisProperty]
    );

    const ctx = this.myChart.nativeElement.getContext('2d');
    this.myChartInstance = new Chart(ctx, {
      type: selectedChartType,
      data: {
        labels: labels,
        datasets: [
          {
            label: 'Values',
            data: dataValues,
            backgroundColor: [
              'rgba(255, 99, 132, 0.2)',
              'rgba(54, 162, 235, 0.2)',
              'rgba(255, 206, 86, 0.2)',
              'rgba(75, 192, 192, 0.2)',
              'rgba(153, 102, 255, 0.2)',
              'rgba(255, 159, 64, 0.2)',
            ],
            borderColor: [
              'rgba(255, 99, 132, 1)',
              'rgba(54, 162, 235, 1)',
              'rgba(255, 206, 86, 1)',
              'rgba(75, 192, 192, 1)',
              'rgba(153, 102, 255, 1)',
              'rgba(255, 159, 64, 1)',
            ],
            borderWidth: 1,
          },
        ],
      },
      options: {
        scales: {
          y: {
            beginAtZero: true,
          },
        },
      },
    });
  }
  printAsPDF() {
    if (this.myChartInstance) {
      const chartCanvas = this.myChart.nativeElement;
      const chartImage = chartCanvas.toDataURL('image/png', 1.0);
      const pdf = new jsPDF();
      pdf.addImage(chartImage, 'PNG', 0, 0, 210, 150);
      pdf.save('chart.pdf');
    } else {
      this.snackBarService.open(
        'Please Get Properties First to Generate Graphic Raport'
      );
    }
  }
}
